package robot.actuator;

/**
 * Protocole des actionneurs
 * @author pf
 *
 */

// DEPENDS_ON_RULES
public enum ActuatorOrder {
		
	AX12_AVANT_GAUCHE_90(true, AX12.AX12_AVANT_GAUCHE, AngleAX12.OUVERT_90.angleSym),
	AX12_AVANT_DROIT_90(true, AX12.AX12_AVANT_DROIT, AngleAX12.OUVERT_90.angle),
	
	AX12_AVANT_GAUCHE_OUVERT1(true, AX12.AX12_AVANT_GAUCHE, AngleAX12.OUVERT1.angleSym),
	AX12_AVANT_DROIT_OUVERT1(true, AX12.AX12_AVANT_DROIT, AngleAX12.OUVERT1.angle),
	
	AX12_AVANT_GAUCHE_OUVERT2(true, AX12.AX12_AVANT_GAUCHE, AngleAX12.OUVERT2.angleSym),
	AX12_AVANT_DROIT_OUVERT2(true, AX12.AX12_AVANT_DROIT, AngleAX12.OUVERT2.angle),
	
	AX12_AVANT_GAUCHE_VERR1(true, AX12.AX12_AVANT_GAUCHE, AngleAX12.VERR1.angleSym),
	AX12_AVANT_DROIT_VERR1(true, AX12.AX12_AVANT_DROIT, AngleAX12.VERR1.angle),
	
	AX12_AVANT_GAUCHE_VERR2(true, AX12.AX12_AVANT_GAUCHE, AngleAX12.VERR2.angleSym),
	AX12_AVANT_DROIT_VERR2(true, AX12.AX12_AVANT_DROIT, AngleAX12.VERR2.angle),
	
	AX12_AVANT_GAUCHE_FERME(true, AX12.AX12_AVANT_GAUCHE, AngleAX12.FERME.angleSym),
	AX12_AVANT_DROIT_FERME(true, AX12.AX12_AVANT_DROIT, AngleAX12.FERME.angle),
	
	AX12_ARRIERE_GAUCHE_90(true, AX12.AX12_ARRIERE_GAUCHE, AngleAX12.OUVERT_90.angle),
	AX12_ARRIERE_DROIT_90(true, AX12.AX12_ARRIERE_DROIT, AngleAX12.OUVERT_90.angleSym),
	
	AX12_ARRIERE_GAUCHE_OUVERT1(true, AX12.AX12_ARRIERE_GAUCHE, AngleAX12.OUVERT1.angle),
	AX12_ARRIERE_DROIT_OUVERT1(true, AX12.AX12_ARRIERE_DROIT, AngleAX12.OUVERT1.angleSym),
	
	AX12_ARRIERE_GAUCHE_OUVERT2(true, AX12.AX12_ARRIERE_GAUCHE, AngleAX12.OUVERT2.angle),
	AX12_ARRIERE_DROIT_OUVERT2(true, AX12.AX12_ARRIERE_DROIT, AngleAX12.OUVERT2.angleSym),
	
	AX12_ARRIERE_GAUCHE_VERR1(true, AX12.AX12_ARRIERE_GAUCHE, AngleAX12.VERR1.angle),
	AX12_ARRIERE_DROIT_VERR1(true, AX12.AX12_ARRIERE_DROIT, AngleAX12.VERR1.angleSym),
	
	AX12_ARRIERE_GAUCHE_VERR2(true, AX12.AX12_ARRIERE_GAUCHE, AngleAX12.VERR2.angle),
	AX12_ARRIERE_DROIT_VERR2(true, AX12.AX12_ARRIERE_DROIT, AngleAX12.VERR2.angleSym),
	
	AX12_ARRIERE_GAUCHE_FERME(true, AX12.AX12_ARRIERE_GAUCHE, AngleAX12.FERME.angle),
	AX12_ARRIERE_DROIT_FERME(true, AX12.AX12_ARRIERE_DROIT, AngleAX12.FERME.angleSym),

	AX12_POISSON_BAS(false, AX12.AX12_PORTE_CANNE, AngleAX12.POISSON_BAS.angle),

	AX12_POISSON_OUVRE(false, AX12.AX12_LACHE_POISSON, AngleAX12.POISSON_OUVRE.angle),
	AX12_POISSON_FERME(false, AX12.AX12_LACHE_POISSON, AngleAX12.POISSON_FERME.angle),

	AX12_POISSON_MILIEU(false, AX12.AX12_PORTE_CANNE, AngleAX12.POISSON_MILIEU.angle),
	AX12_POISSON_HAUT(false, AX12.AX12_PORTE_CANNE, AngleAX12.POISSON_HAUT.angle),

	TEST(false, AX12.AX12_GROS_1, AngleAX12.FERME.angle);
	
	public final boolean symetrie;
	public final int id;
	public final int angle;
	
	private ActuatorOrder(boolean symetrie, AX12 ax, int angle)
	{
		this.id = ax.id;
		this.angle = angle;
		this.symetrie = symetrie;
	}
	
	/**
	 * Renvoie le sym√©trique de l'ordre
	 * @param symetrie
	 * @return
	 */
	public ActuatorOrder getSymetrie(boolean symetrie)
	{
		if(symetrie)
			return values()[ordinal()^1];
		else
			return this;
	}
	
}
