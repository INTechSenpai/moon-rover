\documentclass[a4paper, 12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais,english]{babel}
\usepackage{hyperref}
\usepackage{alltt}
\title{Documentation du code HL de gestion de la série}
 
\author{Moon-rover}

\date{}

\begin{document}

\selectlanguage{francais}
\maketitle

\pagestyle{plain}

\section{Fichiers}

Les fichiers qui interviennent dans la gestion de la série sont :
\begin{description}
\item[src/serie]
le code de gestion de la série
\item[src/serie/trame]
des structures de données, presque pas de code
\item[src/threads/ThreadSerialInputCoucheTrame]
thread qui appelle la gestion bas niveau (couche trame) des trames entrantes
\item[src/threads/ThreadSerialInputCoucheOrdre]
thread qui appelle la gestion haut niveau (couche ordre) des trames entrantes
\item[src/threads/ThreadSerialOutput]
thread qui envoie de nouvelles trames
\item[src/threads/ThreadSerialOutputTimeout]
thread qui s'occupe des renvois de trames
\end{description}

De plus, tu peux ignorer les fichiers \textbf{SerialInterface} et \textbf{SerialSimulation} qui sont utilisés pour simuler une série (quand je n'ai pas le hardware)

Enfin, il y des variables de configuration, situées dans \textbf{src/utils/Config} :
\begin{description}
\item[\texttt{debugSerie}] permet un debug de la série en affichant des infos sur la communication en cours
\item[\texttt{debugSerieTrame}] permet un debug de la série en affichant le contenu hexadécimal de toutes les trames envoyées et reçues
\end{description}

Par défaut, j'ai mis les deux à \texttt{true} ; si ça spamme trop, modifie-les.

Le cœur du code est dans \textbf{SerieCoucheTrame}, qui est normalement bien documenté. Quelques autres endroits utiles :

\begin{description}
\item[src/serie/trame/OutgoingFrame] là où une trame sortante est construite
\item[src/serie/trame/IncomingFrame] là où on vérifie le checksum d'une trame entrante
\end{description}

\section{Envoi d'un ordre}

Voici un exemple de l'utilisation de l'architecture dans le cas de l'envoi d'un ordre.

Pour envoyer un ordre, il faut appeler une méthode de \textbf{BufferOutgoingOrder}. Cette classe a des méthodes du genre "avancer", "demande la couleur", etc.

Dans notre exemple, on va faire une demande de couleur. Dans un \texttt{main} ou un test, on met alors :

\begin{alltt}
// Récupération de data par le container
BufferOutgoingOrder data = (BufferOutgoingOrder)
      container.getService(ServiceNames.SERIAL_OUTPUT_BUFFER);
data.demandeCouleur();
\end{alltt}

\texttt{BufferOutgoingOrder} s'occupe de construire l'ordre et fait un \texttt{notify} qui appelle le thread \textbf{ThreadSerialOutput}.

Le rôle de ce thread est juste de passer cet ordre à \textbf{SerieCoucheTrame} qui va s'occuper de son envoi.

On arrive du coup dans \textbf{SerieCoucheTrame}, le fichier le plus important de la série car c'est lui qui implémente le protocole des trames.

Dans cette méthode, on peut trouver des listes:

\begin{description}
\item[\texttt{waitingFrames}] : contient les trames dont on n'a pas encore reçu un acquittement. Elles sont susceptibles d'être renvoyées.
\item[\texttt{pendingLongFrames}] : contient les ordres longs qui ne sont pas encore terminés.
\item[\texttt{closedFrames}] : contient les ordres qui sont finis (\texttt{VALUE\_ANSWER} ou \texttt{EXECUTION\_END}) mais qu'on doit garder encore un peu avant de les détruire.
\end{description}

Quand on envoie un nouvel ordre, on l'ajoute à \texttt{waitingFrames} et on demande à la série de la couche physique d'effectuer l'envoi.

\section{Réception d'une trame}

Le thread qui s'occupe d'écouter la série est \textbf{ThreadSerialInputCoucheTrame}. Son code utilise la méthode \textbf{readData} de \textbf{SerieCoucheTrame}. Cette méthode fait deux appels :
\begin{description}
\item[readFrame] qui construit la trame, vérifier la longueur, le checksum, etc.
\item[processFrame] qui réagit à cette trame : c'est cette méthode qui s'occupe réellement du protocole des frames. Elle fait évoluer l'état des ordres en cours, répond s'il le faut, etc.
\end{description}

readData est bloquante. Quand on reçoit une trame : soit c'est une trame de signalisation (EXECUTION\_END, EXECUTION\_BEGIN) et readData reste bloquée (car ce n'est pas une trame pour le haut niveau), soit c'est une trame contenant des infos, et dans ce cas readData renvoie la trame à \textbf{ThreadSerialInputCoucheTrame}. Cette trame est ensuite mise dans un buffer et est décodée dans \textbf{ThreadSerialInputCoucheOrdre} qui exécute leurs ordres.

\end{document}